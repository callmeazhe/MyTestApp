package com.example.mytestapp.nfc.utils;


import java.io.UnsupportedEncodingException;
import java.util.Map;
import java.util.Set;

/**
 * A tool class that handles byte arrays, providing interchanger between int and byte array,
 * text and byte array
 * Created by 30035027 on 8/4/2017.
 */

public class ByteArrayUtils {

    /**
     * String t0 bytes
     *
     * @param text        convert target text
     * @param size        Generate the size of the data byte array
     * @param charsetName the encoding of text bytes
     * @return text bytes
     * @throws UnsupportedEncodingException
     */
    public static byte[] stringToByteArray(String text, int size, String charsetName) throws UnsupportedEncodingException {
        if (text != null) {
            byte[] textData;
            if (charsetName != null)
                textData = text.getBytes(charsetName);
            else {
                //UTF-8
                textData = text.getBytes();
            }
            if (textData.length <= size) {
                byte[] data = new byte[size];
                System.arraycopy(textData, 0, data, 0, textData.length);
                return data;
            } else {
                throw new IllegalArgumentException("text length greater than size");
            }

        } else
            throw new IllegalArgumentException("text is null");
    }

    /**
     * byteArray to text
     *
     * @param textData    text byte array
     * @param charsetName the encoding of text bytes
     * @return Text generated by bytes
     * @throws UnsupportedEncodingException  UnsupportedEncodingException
     */
    public static String byteArrayToString(byte[] textData, String charsetName) throws UnsupportedEncodingException {
        if (textData != null) {
            // ignore 0 at the end of byte array
            int length = textData.length;
            for (int i = 0; i < textData.length; i++) {
                if (textData[i] == 0) {
                    length = i;
                    break;
                }
            }
            return new String(textData, 0, length, charsetName);
        } else {
            throw new IllegalArgumentException("textData is null");
        }
    }

    /**
     * Convert a number to bytes, and you can specify the number of return bytes.
     * the Low of int => the High of bytes
     *
     * @param value convert target
     * @param len   Generate the length of the array
     * @return Number generated by bytes
     */
    public static byte[] intToBytes(int value, int len) {
        if (len <= 0)
            throw new IllegalArgumentException("len not less than or equal to 0");
        byte[] b = new byte[len];
        for (int i = 0; i < len; i++) {
            b[len - i - 1] = (byte) ((value >> 8 * i) & 0xff);
        }
        return b;
    }

    /**
     * Convert the specified bytes to int
     * the High of bytes => the Low of int
     *
     * @param data       number
     * @param startIndex Start the subscript
     * @param len        Number of bytes transferred
     * @return a number
     */
    public static int bytesToInt(byte[] data, int startIndex, int len) {
        if (data == null) {
            throw new IllegalArgumentException("Data can't be null");
        }
        if (data != null && data.length == 0) {
            throw new IllegalArgumentException("Data length can't be 0");
        }
        if (len <= 0) {
            throw new IllegalArgumentException("Len can't be 0");
        }
        if (startIndex >= data.length) {
            throw new IllegalArgumentException("StartIndex can't be greater than data length");
        }
        if (data.length < (startIndex + len))
            throw new IllegalArgumentException("startIndex insert len can't be greater than data length");
        int sum = 0;
        int endIndex = startIndex + len;
        for (int i = startIndex; i < endIndex; i++) {
            int temp = ((int) data[i]) & 0xff;
            int moveBits = (--len) * 8;
            temp = temp << moveBits;
            sum += temp;
        }
        return sum;
    }

    /**
     * Concat two byte array to one
     *
     * @param one a ByteArray
     * @param two a ByteArray
     * @return The concat array
     */
    public static byte[] concat(byte[] one, byte[] two) {
        if (one == null || two == null) {
            throw new IllegalArgumentException("one or two can't be null");
        }
        byte[] combined = new byte[one.length + two.length];
        System.arraycopy(one, 0, combined, 0, one.length);
        System.arraycopy(two, 0, combined, one.length, two.length);
        return combined;
    }

    /**
     * Is the array the same
     *
     * @param one
     * @param two
     * @return
     */
    public static boolean isSameArray(byte[] one, byte two[]) {
        if (one == null) {
            throw new IllegalArgumentException("one can't be null");
        }
        if (two == null) {
            throw new IllegalArgumentException("two can't be null");
        }

        if (one.length != two.length) {
            return false;
        }
        for (int i = 0; i < one.length; i++) {
            if (one[i] != two[i])
                return false;
        }
        return true;
    }

    /**
     * Converts the hexadecimal string into a byte array
     * e.g. "ABCD" =>  byte[0]:AB ,byte[1]:CD
     *
     * @param hex
     * @return
     */
    public static byte[] hexStringToByte(String hex) {
        if (hex == null) {
            throw new IllegalArgumentException("hex can't be null");
        }
        hex = hex.replaceAll(":", "");
        int remainder = (hex.length() % 2);
        if (remainder != 0) {
            throw new IllegalArgumentException("Hex length must be even number");
        }

        hex = hex.toUpperCase();
        int len = (hex.length() / 2);
        byte[] result = new byte[len];
        char[] aChar = hex.toCharArray();
        for (int i = 0; i < len; i++) {
            int pos = i * 2;
            result[i] = (byte) (toByte(aChar[pos]) << 4 | toByte(aChar[pos + 1]));
        }
        return result;
    }

    /**
     * Find the index in the string "0123456789ABCDEF", and do not return -1
     *
     * @param covert covert char
     * @return index in the string "0123456789ABCDEF", and do not return -1
     */
    private static byte toByte(char covert) {
        byte b = (byte) "0123456789ABCDEF".indexOf(covert);
        return b;
    }

    /**
     * Converts the byte array to a hexadecimal string
     * e.g. byte[0]:AB ,byte[1]:CD => "ABCD"
     *
     * @param bArray
     * @return String
     */
    public static String bytesToHexString(byte[] bArray) {
        if (bArray == null) {
            throw new IllegalArgumentException("bArray can't be null");
        }
        StringBuffer sb = new StringBuffer(bArray.length);
        String sTemp;
        for (int i = 0; i < bArray.length; i++) {
            // "0xFF & bArray[i]" could make bArray to int
            sTemp = Integer.toHexString(0xFF & bArray[i]);
            if (sTemp.length() < 2)
                sb.append(0);
            sb.append(sTemp.toUpperCase());
            if (i != bArray.length - 1) {
                sb.append(":");
            }
        }
        return sb.toString();
    }

    /**
     * Half float int  to  float32
     *
     * @param halfFloat the int value of the Float16
     * @return float32
     */

    public static float halfFloatToFloat(int halfFloat) {
        //Infinitesimal and 0
        if (halfFloat == 0) {
            return 0.0f;
            //infinity
        } else if (halfFloat == ((halfFloat & 0x8000) & 0x7c00)) {
            return Float.intBitsToFloat(0x7f800000);
            //NaN
        } else if (halfFloat == 0x7fff) {
            return Float.intBitsToFloat(0x7fc00000);
        } else {
            int floatInt = ((halfFloat & 0x8000) << 16) | (((((halfFloat >> 10) & 0x1f) - 15 + 127) & 0xff) << 23) | ((halfFloat & 0x03FF) << 13);
            return Float.intBitsToFloat(floatInt);
        }
    }


    /**
     * Float to half float16 int
     *
     * @param f float number
     * @return float16 int
     */
    public static int floatToHalfFloat(float f) {

        int floatInt = Float.floatToIntBits(f);
        //NaN
        if (floatInt == 0x7fc00000) {
            return 0x7fff;
            //infinity
        } else if (floatInt == 0x7f800000) {
            return 0x7c00;
        } else if (floatInt == 0xff800000) {
            return 0xfc00;
        } else if (floatInt == 0) {
            return 0x0000;
        } else {
            return ((floatInt >> 16) & 0x8000) | ((((floatInt >> 23) - 127 + 15) & 0x1f) << 10) | ((floatInt >> 13) & 0x3ff);

        }
    }


    /**
     * Half float int  to  float32
     *
     * @param floatArr the int value of the Float16
     * @return float32
     */

    public static float bytesToFloat(byte[] floatArr) {
        return Float.intBitsToFloat(bytesToInt(floatArr, 0, 4));
    }


    /**
     * Float to half float16 int
     *
     * @param f float number
     * @return float16 int
     */
    public static byte[] floatToBytes(float f) {
        return intToBytes(Float.floatToIntBits(f), 4);
    }

    /**
     * Keep three decimal
     */
    public static String floatToThreeDecimalPointString(float value) {
        return NumberUtil.setFormatDecimalsValue(value, 3);
    }

    public static String floatToOneDecimalPointString(float value) {
        return NumberUtil.setFormatDecimalsValue(value, 1);
    }
    public static String floatToTwoDecimalPointString(float value) {
        return NumberUtil.setFormatDecimalsValue(value, 2);
    }

    /**
     * e.g. value= 8 bitIndex = 3- > return 1
     * e.g. value= 8 bitIndex = 2- > return 0
     */
    public static int getBitFromInt(int value, int bitIndex) {
        if (bitIndex < 0) {
            throw new IllegalArgumentException("bitIndex not less than 0");
        }
        return (value >> bitIndex) & 1;
    }

    /**
     * e.g. bitIndex={0,1,2}-> binary value:0111 return 7
     */
    public static int getIntFromBit(Map<Integer, Boolean> mMap) {
        if (mMap == null)
            throw new IllegalArgumentException("bitArr can't be null");
        if (mMap.size() < 1)
            throw new IllegalArgumentException("bitArr is length not less 1");
        int temp = 1;
        int values = 0;
        Set<Integer> bitIndex = mMap.keySet();
        for (Integer bit : bitIndex) {
            boolean isSelect = mMap.get(bit);
            if (isSelect)
                values += (temp << bit);
        }
        return values;

    }

    /**
     * Converts the Double into a byte array
     *
     * @param values
     * @return
     */
    public static byte[] doubleToByte(double values) {
        long l = Double.doubleToLongBits(values);
        return longToByte(l, 8);
    }

    public static byte[] longToByte(long value, int len) {
        if (len <= 0)
            throw new IllegalArgumentException("len not less than or equal to 0");
        byte[] b = new byte[len];
        for (int i = 0; i < len; i++) {
            b[len - i - 1] = (byte) ((value >> 8 * i) & 0xff);
        }
        return b;
    }

    /**
     * Convert the specified bytes to double
     *
     * @param bytes
     * @return
     */
    public static double byteToDouble(byte[] bytes) {
        long m;
        m = bytes[0];
        m &= 0xff;
        m |= ((long) bytes[1] << 8);
        m &= 0xffff;
        m |= ((long) bytes[2] << 16);
        m &= 0xffffff;
        m |= ((long) bytes[3] << 24);
        m &= 0xffffffffl;
        m |= ((long) bytes[4] << 32);
        m &= 0xffffffffffl;
        m |= ((long) bytes[5] << 40);
        m &= 0xffffffffffffl;
        m |= ((long) bytes[6] << 48);
        m &= 0xffffffffffffffl;
        m |= ((long) bytes[7] << 56);
        return Double.longBitsToDouble(m);
    }
}